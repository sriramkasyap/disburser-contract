// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

// Uncomment this line to use console.log
import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// Interfaces

interface IAllowanceModule {
    function executeAllowanceTransfer(
        address safe,
        address token,
        address payable to,
        uint96 amount,
        address paymentToken,
        uint96 payment,
        address delegate,
        bytes memory signature
    ) external;
}

/**
 * @title Disburser
 * @dev Disburser contract for orgs to distribute funds to their members without having their addresses beforehand. This uses Merkle trees to verify that the members are part of the org. Orgs submit a Merkle tree root generated from the members emails, tokens and amounts to be distributed. Members can then claim their tokens by submitting their email, token and proof of inclusion in the Merkle tree.
 * @author Sriram Kasyap Meduri
 */

contract Disburser {
    // STORAGE

    // Owner of the contract, aka the Org Safe
    address public owner;

    // Merkle tree root submitted by the Org Safe
    bytes32 public merkleRoot;

    // Allowance Module Address
    address public constant ALLOWANCE_MODULE = 0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134;

    /**
     * @dev This mapping stores the nonces of the members who have claimed their tokens. This is to prevent replay attacks. The nonces are packed into a uint256 to save on gas costs.
     * @dev The value of the mapping is a uint256 which has nonce status of 256 nonces. Each nonce status is a bit in the uint256. If the bit is 1, the nonce has been used. If the bit is 0, the nonce has not been used.
     * @dev The key of the mapping is the index of the nonces. The index is calculated by dividing the nonce by 256 and the remainder is the index.
     * @dev For example, if the nonce is 1000, the index is 3 and the bit position is 232 (1000 % 256). If the nonce is 1001, the index is 3 and the bit position is 233 (1001 % 256).
     */
    mapping(uint256 => uint256) public claimedNonces;

    // EVENTS
    event ClaimedPayout(address indexed member, address indexed orgAddress, address indexed token, uint256 amount);

    // MODIFIERS
    modifier onlyOwner() {
        require(msg.sender == owner, "Disburser: Only the owner can call this function");
        _;
    }

    // CONSTRUCTOR
    constructor(address _owner) {
        require(_owner != address(0), "Disburser: Owner cannot be 0");
        owner = _owner;
    }

    // Update Merkle root
    function updateMerkleRoot(bytes32 _merkleRoot) external {
        merkleRoot = _merkleRoot;
    }

    // Get nonce status
    function getNonceStatus(uint256 _nonce) public view returns (uint256) {
        uint256 index = _nonce / 256;
        uint256 position = _nonce % 256;
        uint256 nonceStatus = claimedNonces[index];
        uint256 mask = (1 << position);
        return (nonceStatus & mask);
    }

    // Update Nonce status
    function _updateNonceStatus(uint256 _nonce, uint256 _nonceStatus) internal {
        uint256 index = _nonce / 256;
        uint256 position = _nonce % 256;
        uint256 nonceStatus = claimedNonces[index];
        uint256 mask = (1 << position);
        if (_nonceStatus == 1) {
            claimedNonces[index] = nonceStatus | mask;
        } else {
            claimedNonces[index] = nonceStatus & ~mask;
        }
    }

    /**
     * @dev Encode the transaction data for the payout
     * @param tokenAddress Address of the token to send
     * @param amount Amount of tokens to send
     * @param payoutNonce Payout nonce to use
     * @return encodedHash Encoded hash of the transaction data
     */
    function encodeTransactionData(
        address tokenAddress,
        uint256 amount,
        uint256 payoutNonce
    ) public view returns (bytes32) {
        return keccak256(abi.encode(owner, tokenAddress, amount, payoutNonce));
    }

    function testClaim(
        address _token,
        uint256 _amount,
        uint256 _nonce,
        bytes32[] calldata _proof
    ) external view returns (bool) {
        bytes32 leafNode = encodeTransactionData(_token, _amount, _nonce);
        return MerkleProof.verify(_proof, merkleRoot, leafNode);
    }

    /**
     * @dev This function is called by the members to claim their tokens. The members need to submit their email, token and proof of inclusion in the Merkle tree.
     * @dev The proof is an array of bytes32 which contains the sibling hashes of the leaf node. The sibling hashes are ordered from left to right.
     * @dev The leaf node is the keccak256 hash of the member's email, token, amount and nonce
     * @dev The nonce is a random number generated by the member. This is to prevent replay attacks. The nonce has to be unique for each claim, and should bot be already occupied in the claimedNonces mapping.
     */
    function claimPayout(address _token, uint256 _amount, uint256 _nonce, bytes32[] calldata _proof) external {
        // Check if the nonce has been used
        require(_nonce != 0, "Disburser: Nonce cannot be 0");
        require(getNonceStatus(_nonce) == 0, "Disburser: Nonce has already been used");

        // Require amount to be greater than 0
        require(_amount > 0, "Disburser: Amount cannot be 0");

        // Check if the merkle root has been set
        require(merkleRoot != bytes32(0), "Disburser: Merkle root has not been set");

        // Check if the payoutDetails hash is part of the Merkle tree
        bytes32 leafNode = encodeTransactionData(_token, _amount, _nonce);

        require(MerkleProof.verify(_proof, merkleRoot, leafNode), "Disburser: Invalid proof");

        // Transfer tokens to the member using AllowanceModule of Gnosis Safe
        execTransferFromSafe(_token, uint96(_amount), msg.sender);

        // Update nonce status
        _updateNonceStatus(_nonce, 1);
    }

    /**
     * @dev Execute transfer from Gnosis Safe
     * @param tokenAddress Address of the token to send
     * @param amount Amount of tokens to send
     */
    function execTransferFromSafe(address tokenAddress, uint96 amount, address recepient) internal {
        // Execute payout via allowance module
        // Fetch amount is the difference between the flag token amount to fetch and the current token balance
        IAllowanceModule(ALLOWANCE_MODULE).executeAllowanceTransfer(
            owner,
            tokenAddress,
            payable(recepient),
            amount,
            address(0),
            0,
            address(this),
            bytes("")
        );
    }
}
